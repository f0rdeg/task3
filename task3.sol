
/**
 * This file was generated by TONDev.
 * TONDev is a part of TON OS (see http://ton.dev).
 */
pragma ton-solidity >= 0.35.0;
pragma AbiHeader expire;

// This is class that describes you smart contract.
contract task3 {
    string[] queue;
    struct work {
        string name;
        uint32 timestamp;
        bool toggle;
    }
    mapping (int8=>work) listW;
    constructor() public {
        require(tvm.pubkey() != 0, 101);
        require(msg.pubkey() == tvm.pubkey(), 102);
        tvm.accept();
    }

    function addWorkNumber(string name,int8 number) public {
        tvm.accept();
        listW.add(number,work(name,now,false));
    }

    function incompleteWork() public view returns (int8){
        tvm.accept();
        int8 count = 0;
        optional (int8, work) currentOpt = listW.min();
        
        while (currentOpt.hasValue()){
            (int8 key, work val) = currentOpt.get();
            if (!(val.toggle)) {
                count++;
            }
            currentOpt = listW.next(key);
        }
        return count;
    }
    function listWork() public view returns (work[]){
        tvm.accept();
        optional (int8, work) currentOpt = listW.min();
        work[] resArr;
        while (currentOpt.hasValue()){
            (int8 key, work val) = currentOpt.get();
            resArr.push(val);
            currentOpt = listW.next(key);
        }
        return resArr;
    }
    function workNumber(int8 number) public view returns (work){
        tvm.accept();
        return listW[number];
    }
    function delWorkNumber(int8 number) public{
        tvm.accept();
        delete listW[number];
    }
    function trueWorkNumber(int8 number) public{
        tvm.accept();
        listW[number].toggle = true;
    }
    function toGetInLine (string name) public {
        tvm.accept();
        queue.push(name);
    }
    
    function callNext() public returns (string){
        tvm.accept();
        string s = queue[0];
        for (uint256 index = 0; index < queue.length-1; index++) {
            queue[index] = queue[index+1];
        }
        queue.pop();
        return s;
    }

}
